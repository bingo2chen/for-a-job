### 数组去重
```js
const array = [1,2,3,3,3,4,5,5,5,6,6,6,7,7,8,8,9,0,0,0]

const newArray1 = [...new Set(array)]
const newArray2 = Array.from(new Set(array))
const newArray3 = array.filter((arr, index) => array.indexOf(arr) === index)
```

### 数组映射
```js
const array = [
  {
    id: 1,
    name: '小红',
  },
  {
    id: 2,
    name: '小李',
  }
]

const newArray1 = Array.from(array, arr => arr.name)
const newArray2 = array.map(arr => arr.name)
```

### 数组求和
```js
const array = [1,2,3,4,5,6,7,8,9,10]

array.reduce((prev, cur) => prev + cur)
```

### 数组扁平化
```js
const array = [[1,2,3],4,5,[6,7,[8,9,[10,11]]]]

array.flat(3)
```

### 数组排序
```js
const array = [1,2,3,9,8,7,5]

array.sort((a, b) => a - b)
```

### 数组最大值
```js
const array = [1,2,3,9,8,7,5]

Math.max(...array)
Math.max.apply(this, array)
array.reduce((prev, cur) => Math.max(prev, cur))
```

### 数组合并
```js
const arr1 = [1,2,3].concat([5,6,7])
const arr2 = [...[1,2,3],...[5,6,7]]
const arr3 = [1,2,3].push.apply([1,2,3], [5,6,7])
```

### 判断是否包含值
```js
[1,2,3].includes(4)
[1,2,3].indexOf(4)
[1,2,3].find(item => item === 4)
[1,2,3].findIndex(item => item === 4)
```

### 类数组转化
```js
Array.prototype.slice.apply(arguments)
Array.prototype.slice.call(arguments)
Array.from(arguments)
[...arguments]
```

### 设置每一项的值
```js
[1,2,3,4,5,6].map(() => 666)
```

### 每一项是否满足
```js
[1,2,3,4,5,6,7].every(item => item > 0)
```

### 有一项是否满足
```js
[1,2,3,4,5,6,7].some(item => item > 6)
```

### 过滤数组
```js
[1,2,3,4,5,6,7].filter(item => item > 6)
```

### 对象数组转化
```js
Object.keys({name: 'zhangsan', age: 18}) // [name, age]
Object.values({name: 'zhangsan', age: 18}) // [zhangsan, 18]
Object.entries({name: 'zhangsan', age: 18}) // [[name,'张三'],[age,14]]
```

### 实现一个 flat 方法，可以根据传入的层级展开对应深度的数组嵌套：

```js
// 例子：
var arr1 = [1, 2, [3, 4], [5, 6]];
arr1.flat(); 
// [1, 2, 3, 4, 5, 6]

var arr2 = [1, 2, [3, 4, [5, 6]], [7, 8]];
arr2.flat();
// [1, 2, 3, 4, [5, 6], 7, 8]

var arr3 = [1, 2, [3, 4, [5, 6]]];
arr3.flat(2);
// [1, 2, 3, 4, 5, 6]

//使用 Infinity，可展开任意深度的嵌套数组
var arr4 = [1, 2, [3, 4, [5, 6, [7, 8, [9, 10]]]]];
arr4.flat(Infinity);
// [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

var checkType = type => target => `[object ${type}]` === Object.prototype.toString.call(target)

Array.prototype.flatten = function(depth = 1) {
  if (!Array.isArray(this)) return
  const ret = []
  this.forEach((item, index) => {
    if (Array.isArray(item)) {
      depth--
      if (depth < 0) {
        return ret.push(item)
      }
      ret.push(...item.flatten(depth))
    } else {
      ret.push(item)
    }
  })
  return ret
}
```


```js

var data = [
  {name:'a',id:1,pid:0},
  {name:'b',id:2,pid:1},
  {name:'c',id:3,pid:1},
  {name:'d',id:4,pid:2},
]

// 写函数将上面data转换成如下
data = [
   {name:'a',id:1,pid:0,children:[
      {name:'b',id:2,pid:1,children:[
          {name:'d',id:4,pid:2,children:[]}
      ]},
      {name:'c',id:3,pid:1,children:[]},
   ]},
]

```

### 数组乱序
```js
input: [1, 2, 3, 4, 5]
output: [3, 4, 2, 5, 1] 
/**
 * @param {Array} arr
 * @returns {Array}
 */
function shuffle(arr) {
  return arr.sort(() => 0.5 - Math.random())
}
```

### splice
- 会改变原数组


### 求两个数组交集：nums1 = [1, 2, 2, 1]， nums2 = [2, 2]， 返回 [2, 2]
```js
// 交集
function bar1(nums1, nums2) {
  return nums1.filter(v => nums2.indexOf(v) !== -1)
}
// 并集
function bar2(nums1, nums2) {
  return new Set([...nums1, ...nums2])
}
// 差集
function bar3(nums1, nums2) {
  return nums1.filter(v => nums2.indexOf(v) === -1)
}
```