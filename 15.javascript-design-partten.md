### JavaScript 设计模式与开发实践 笔记
##### 单例模式
- 核心: 确保只有一个实例，并提供全局访问
- 重点：惰性单例
- 场景：单一对象，弹窗，无论被点击多少次，只会被创建一次，用到变量缓存
```js
const getSingleInstance = function (fn){
  let result
  return result || (result = fn.apply(this, arguments))
}
```
##### 观察者模式/订阅-发布模式（pub/sub）
```js
class Event {
  constructor() {
    this.callbacks = []
  }
  $on(name, fn) {
    (this.callbacks[name]) || (this.callbacks[name] = []).push(fn)
  }
  $emit(name) {
    let cbs = this.callbacks[name]
    if (cbs) {
      cbs.forEach(c => {
        c.call(this, arguments)
      })
    }
  }
  $off(name) {
    this.callbacks[name] = null
  }
}

// 测试
const event = new Event()
event.$on('Where are you?', function(params) {
  console.log('事件1', params)
})
event.$on('How are you?', function(params) {
  console.log('事件2', params)
})
event.$emit('How are you?', {abc: 123})
event.$emit('Where are you?', {def: 987})
event.$off('How are you?')
event.$emit('How are you?', {abc: 123})
```
##### 策略模式
##### 代理模式
##### 中介者模式
##### 装饰器模式
##### 外观模式
- 让多个方法一起被调用
- 对外暴露统一的api
```js
const A = {
  a1(),
  a2()
}
const B = {
  b1(),
  b2()
}
const getAll = {
  A()
  B()
}
getAll()
```
##### 工厂模式
- 提供创建对象的接口，把成员对象的创建工作交给另一个外部对象，好处在于消除对象直接的耦合
##### 建造者模式
- 与工厂模式相比，建造者模式参与了更多创建的过程，或者更加复杂
##### 迭代器模式
```js
const each = function(arr, callbacks) {
  for(let i = 0; i < arr.length; i++) {
    callbacks.call(arr[i], i, arr[i])
  }
}
each([3,2,1,0,10], function(item, index) {
  console.log(item, index)
})
```
##### 享元模式
##### 适配器模式
##### 职责链模式
##### 模板方法模式
##### 备忘录模式