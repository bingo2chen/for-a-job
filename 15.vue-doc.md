### Vue官网文档
##### vue 实例
- 阻止修改现有的property，使现有响应式系统无法再追踪变化
```js
Object.freeze()
```
- 一些实例property与方法
```js
const data = {a: 1}
const vm = new Vue({
  el: '#example'
  // data: data // 对象
  data: {
    item: ['a', 'b', 'c', 'd']  // 数组
  }
})
vm.$el === document.getElementById('example')
vm.$data === data
vm.$watch('a', function(newValue, oldValue) {})
```
- Vue 不能检测对象和数组的变化
- 如果 data 里的变量不是响应式，怎么让其变为响应式
```js
Vue.set(Object, propertyName, value)
this.$set(this.object, propertyName, value) 
Vue.delete()
this.$delete()
```
- 需求：对一个已有对象赋值多个新property，产生响应式
```js
// 不产生响应式
this.someObject = Object.asign(this.someObject, {a: 1, b: 2})

// 响应式
this.someObject = Object.asign({}, this.someObject, {a: 1, b: 2})
```
- 需求：对一个已有数组产生响应式
```js
// 不产生响应式
vm.item[1] = 'x' 
vm.item.length = 10

// 响应式
Vue.set(vm.item, 1, 'x') // 方式一
vm.item.splice(1, 1, 'x')  // 方式二

vm.$set(vm.item, 1, 'x')

vm.item.splice(10)
```
- 异步更新队列
  + 更新DOM是异步的，监听到数据变化，开启一个异步队列，并缓冲同一事件循环的所有数据变更，同一个watcher被多次触发，只会被推到事件队列一次。在下一次事件循环tick中，vue刷新队列并执行已经去重的工作。Vue在内部对异步队列中执行原生的Promise.then, MutationObserver, setImmediate, 如果环境都不支持执行setTimeout(fn, 0)代替
```js
// 实例中
vm.someData = 'new value'
console.log(vm.$el.textContent) // 未更新
Vue.nextTick(function() {
  console.log(vm.$el.textContent) // 更新
})

// 组件中
method: {
  updateHandler() {
    this.someData = 'new value'
    console.log(this.$el.textContent) // 未更新
    this.$nextTick(function() {
      console.log(this.$el.textContent) // 更新
    })
  }
}

// es2017 async/await 写法
method: {
  async updateHandler() {
    this.someData = 'new value'
    console.log(this.$el.textContent) // 未更新
    await this.$nextTick() // nextTick 返回的是一个promise
    console.log(this.$el.textContent) // 更新
  }
}
```
- 生命周期
  + beforeCreate
    + 实例初始化之后，数据观测、event/watcher事件配置之前被调用
  + created
    + 实例创建完成后立即被调用，挂载阶段还没开始，$el和property尚不可用
  + beforeMount
    + 挂载开始之前被调用，相关的render函数首次被调用
      + 该钩子服务器渲染期间不被调用
  + mounted
    + 实例被挂载后调用，el被新创建的`vm.$el`替代，若根实例挂载在文档内，mounted执行后，vm.$el挂载在文档内
      + 该钩子服务器渲染期间不被调用
  + beforeUpdate
    + 数据更新时被调用，发生在虚拟dom打补丁之前。适合更新之前访问现有dom，比如手动移除已添加的事件监听器
      + 该钩子服务器渲染期间不被调用，仅在服务器初次渲染时进行
  + updated
    + 数据更改导致虚拟dom重新渲染、打补丁后被调用，调用时，组件dom已更新，可以执行依赖dom的操作，应避免这期间改变状态，如果实在要改，用计算属性或者watcher取而代之
      + 该钩子服务器渲染期间不被调用
  + activated
    + 被keep-alive缓存组件激活时被调用
      + 该钩子服务器渲染期间不被调用
  + deactivated
    + 被keep-alive缓存组件停用时被调用
      + 该钩子服务器渲染期间不被调用
  + beforeDestroy
    + 实例销毁之前被调用，这一步实例仍然可以使用
      + 该钩子服务器渲染期间不被调用
  + destroyed
    + 实例销毁后被调用，对应vue的所有指令被解绑，所有的事件监听被移除，所有的子实例被销毁
      + 该钩子服务器渲染期间不被调用
  + errorCaptured 2.5.0+ 新增
    + 当捕获一个来自子孙组件的错误时被调用
##### 计算属性和监听器
- 计算属性 computed
  + 计算属性是基于它们的响应式依赖进行缓存的，只有当他们响应式依赖发生变化时才会重新求值
- 监听器 watcher
  + 当需要在数据变化时执行异步或开销较大的操作时
##### class 和 style 绑定
- class
- class 对象语法
```js
<div
  class="static"
  v-bind:class="{ active: isActive, 'text-danger': hasError }"
></div>
data: {
  isActive: true,
  hasError: false
}
// 渲染结果
<div class="static active"></div>

<div v-bind:class="classObject"></div>
data: {
  classObject: {
    active: true,
    'text-danger': false
  }
}
// 渲染结果
<div class="active"></div>

// 绑定一个返回对象的计算属性
<div v-bind:class="classObject"></div>
data: {
  isActive: true,
  error: null
},
computed: {
  classObject: function () {
    return {
      active: this.isActive && !this.error,
      'text-danger': this.error && this.error.type === 'fatal'
    }
  }
}
```
- class 数组语法
```JS
<div v-bind:class="[activeClass, errorClass]"></div>
data: {
  activeClass: 'active',
  errorClass: 'text-danger'
}
// 渲染结果
<div class="active text-danger"></div>

<div v-bind:class="[isActive ? activeClass : '', errorClass]"></div>

<div v-bind:class="[{ active: isActive }, errorClass]"></div>
```
- style
- style 对象语法
```js
<div v-bind:style="styleObject"></div>
data: {
  styleObject: {
    color: 'red',
    fontSize: '13px'
  }
}
```
- 数组语法
```js
<div v-bind:style="[baseStyles, overridingStyles]"></div>
```
##### 条件渲染
- key 管理可复用的元素
```js
<template v-if="loginType === 'username'">
  <label>Username</label>
  <input placeholder="Enter your username" key="username-input">
</template>
<template v-else>
  <label>Email</label>
  <input placeholder="Enter your email address" key="email-input">
</template>
```
##### ref
- ref 被用来给元素或子组件注册引用信息。引用信息将会注册在父组件的 $refs 对象上。如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例
```js
<p ref="p">hello</p>

<!-- `vm.$refs.child` will be the child component instance -->
<child-component ref="child"></child-component>
```


### Vue Router
- 路由模式
  + history模式 需要后端配置
  + 默认：hash模式
- meta 使用
```js
const router = new VueRouter({
  routes: [
    {
      path: '/foo',
      component: Foo,
      children: [
        {
          path: 'bar',
          component: Bar,
          // a meta field
          meta: { requiresAuth: true }
        }
      ]
    }
  ]
})
router.beforeEach((to, from, next) => {
  if (to.matched.some(record => record.meta.requiresAuth)) {
    // this route requires auth, check if logged in
    // if not, redirect to login page.
    if (!auth.loggedIn()) {
      next({
        path: '/login',
        query: { redirect: to.fullPath }
      })
    } else {
      next()
    }
  } else {
    next() // 确保一定要调用 next()
  }
})
```
