- 解释
  + 深拷贝和浅拷贝都是只针对引用数据类型
    + 浅拷贝只复制指向某个对象的指针，而不是复制对象本身，新旧对象还是共享同一块内存
    + 深拷贝会创造一个一模一样的对象，不共享内存，修改新对象不会改到原对象
- 判断数据类型
  + typeof
  + instanceof
  + constructor
  + Object.prototype.toString.call()

- 浅拷贝
  + const obj2 = Object.assign({}, obj1) 实现浅拷贝
```js
const obj1 = {
  a: 1,
  b: {
    c: 2
  }
}

const obj2 = Object.assign({}, obj1)
obj2.a = 111
obj2.b.c = 222
console.log('obj.a', obj1.a) // 1
console.log('obj.b', obj1.b.c) // 222

```


- 深拷贝
  + const obj2 = JSON.parse(JSON.stringify(obj1))
  + 局限性
    + 无法实现对函数和一些特殊对象的克隆
    + 会摒弃对象的constructor，所有的构造函数都会指向Object
    + 对象的循环引用会报错
  + https://www.jianshu.com/p/2a3728cded4c?utm_campaign=maleskine&utm_content=note&utm_medium=reader_share&utm_source=weixin
```js
const obj1 = {
  a: 1,
  b: {
    c: 2
  }
}

const obj2 = JSON.parse(JSON.stringify(obj1))
obj2.a = 111
obj2.b.c = 222
console.log('obj.a', obj1.a) // 1
console.log('obj.b', obj1.b.c) // 2
```