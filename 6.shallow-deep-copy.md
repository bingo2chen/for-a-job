- 解释
  + 深拷贝和浅拷贝都是只针对引用数据类型
    + 浅拷贝只复制指向某个对象的指针，而不是复制对象本身，新旧对象还是共享同一块内存
    + 深拷贝会创造一个一模一样的对象，不共享内存，修改新对象不会改到原对象
- 判断数据类型
  + typeof
  + instanceof
  + constructor
  + Object.prototype.toString.call()

- 浅拷贝
  + const obj2 = Object.assign({}, obj1) 实现浅拷贝
```js
const obj1 = {
  a: 1,
  b: {
    c: 2
  }
}

const obj2 = Object.assign({}, obj1)
obj2.a = 111
obj2.b.c = 222
console.log('obj.a', obj1.a) // 1
console.log('obj.b', obj1.b.c) // 222

```


- 深拷贝
  + const obj2 = JSON.parse(JSON.stringify(obj1))
  + 局限性
    + 无法实现对函数和一些特殊对象的克隆
    + 会摒弃对象的constructor，所有的构造函数都会指向Object
    + 对象的循环引用会报错
  + https://www.jianshu.com/p/2a3728cded4c?utm_campaign=maleskine&utm_content=note&utm_medium=reader_share&utm_source=weixin
```js
const obj1 = {
  a: 1,
  b: {
    c: 2
  }
}

const obj2 = JSON.parse(JSON.stringify(obj1))
obj2.a = 111
obj2.b.c = 222
console.log('obj.a', obj1.a) // 1
console.log('obj.b', obj1.b.c) // 2
```

- 手写深拷贝函数
```js
const deepclone = function(obj) {
  if (!obj || typeof obj !== 'object') return
  const checkType = Object.prototype.toString.call(obj).slice(8, -1)
  switch(checkType) {
    case 'Array':
      return new Array(obj)
      break
    case 'RegExp':
      return new RegExp(obj)
      break
    case 'Date':
      return new Date(obj)
      break
  }
  const map = deepclone.map = deepclone.map || new Map()
  if (map.get(obj)) {
    return map.get(obj)
  }
  const result = obj instanceof Array ? [] : {}
  map.set(obj, result)
  for(let propName in obj) {
    if (obj.hasOwnProperty(propName)) {
      result[propName] = deepclone(obj[propName])
    }
  }
  return result
}
```