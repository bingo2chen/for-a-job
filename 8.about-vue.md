
### 1. Object.defineProperty 和 Proxy 区别
  + proxy
    + Proxy 可以直接监听对象而非属性
    + Proxy 可以直接监听数组变化
    + Proxy 拦截多达13种，不限于apply、 ownKeys、 deleteProperty、 has等等，Object.defineProperty不具备
    + Proxy 直接返回一个新对象，可以直接操作新对象，Object.defineProperty 只能遍历对象属性直接修改
  + Object.defineProperty
    + 兼容性好,⽀持IE9


  + 原理
  ```js
    Object.keys(data).forEach(function (key) {
      Object.defineProperty(data, key, {
        configurable: true,
        enumerable: true,
        get() {
          console.log('get get get');
        },
        set(newVal) {
          this.val = newVal
          console.log(newVal)
          say(newVal)
        }
      })
    })
  ```

  + 测试代码
  ```js
    // 这是将要被劫持的对象
    // 测试代码
    const data = {
      name: '',
    };
    function say(name) {
      if (name === '古天乐') {
        console.log('给⼤家推荐⼀款超好玩的游戏');
      } else if (name === '渣渣辉') {
        console.log('戏我演过很多,可游戏我只玩贪玩懒⽉');
      } else {
        console.log('来做我的兄弟');
      }
    } 
    data.name = '渣渣辉'
    data.name
  ```


### 2. 如何理解响应式系统
- 每个Vue component 都有一个 watcher 实例与之对应
- Vue 上的data 都会被添加上getter和setter属性
- Vue component render 函数被执行后，data的getter属性会被触碰，此时Vue会记录此时Vue component所依赖的所有data（搜集依赖）
- data被改动是，setter会被调用，此时Vue会通知所有依赖此data的组件去调用他们的render函数进行更新


### 3. key的作用
- key是vnode标记的唯一id，通过key，diff操作更准确和快速
- 准确：不加key，vue会复用节点（vue就地更新策略），导致之前节点的状态会被保留下来，产生一些列bug
- 快速：key的唯一性可被Map数据结构充分利用，遍历查找的时间复杂度为O(1)


### 4. v-if 和 v-for 哪个优先级更高？如果同时出现，怎么优化性能？
- v-for 优先级高于 v-if
- 同时出现，每次渲染都会先执行循环再判断条件，这样很浪费性能
- todo：外层嵌套template，在这一层进行v-if判断；如果判断条件在循环内部，则可以用计算属性过滤掉不需要显示的项


### 5. 组件为什么必须是个函数，Vue根实例没有这个限制
- vue组件有很多实例，如果使用对象的形式定义data，则他们会公用一个data对象，那么状态变更会影响所有组件实例，不合理；
- 采用函数形式定义，在initData时会将其作为工厂函数返回全新data对象，可以有效规避多实例之间状态污染的问题；
- 在Vue根实例没有限制是因为根实例只能有一个


### 6. 怎么理解diff算法
- 通过新旧dom做对比，将变化的地方更新到真实dom上，也需要diff高效的执行对比过程，从而降低时间复杂度O(n)
- 2.x版本为了降低Watcher颗粒度，每一个组件只有一个Watcher与之对应，只有引入diff才能精准找到发生变化的地方
- diff执行的时刻是组件实例执行更新函数时，它会对比上一次渲染结果oldVnode和新的newVnode，这个过程称为patch
- diff过程遵循深度优先，同层比较的策略；两个节点之间会比较他们是否拥有相同的子节点或文本节点做不同操作，比较两组子节点是算法的重点，首先假设头尾节点可能相同，做4次对比尝试，如果没找到相同节点，再按通用方式遍历查找，查找结束再按情况处理剩下节点，借助key可以非常精准查找到相同节点，因此整个patch过程非常高效


### 7. 谈谈对vue组件化的理解
- 组件：独立、可复用，组件系统是Vue核心特性之一
- 组件化开发能大幅提高应用开发效率、测试性和复用性
- 按分类有：页面组件、业务组件、通用组件
- 组件是基于可配置的，平时编写的组件是组件配置而非组件，框架后续会生成其构造函数，基于VueComponent，扩展于Vue
- 常见组件化技术：属性prop，自定义事件，插槽等
- 合理划分组件，有助于提升应用性能
- 组件应该是高内聚低耦合的
- 遵循单向数据流原则


### 8. 谈谈vue设计原则的理解
- 易用性，灵活性，高效性
- 渐进式JavaScript框架


### 9. 谈谈对mvc、mvp、mvvm理解


### 10. 模板到DOM的过程
- 模板->编译->render函数->执行->vnode->patch->视图


### 11. vdom是什么，怎么渲染的
### 12. vue route原理
### 13. 组件拆分         
### 14. 组件拓展
### 15. 处理组件兼容性
### 16. watch如何监听
### 17. 全局loading组件怎么设置 回去项目好好看一遍
### 18. History、Hash路由是怎么实现的
- 参考链接：https://www.cnblogs.com/tugenhua0707/p/10859214.html
- hash
  + 使用hashchange事件来监听url hash的改变
- history
  + HTML5的History API为浏览器的全局history对象增加了该扩展方法。它是一个浏览器的一个接口，在window对象中提供了onpopstate事件来监听历史栈的改变，只要历史栈有信息发生改变的话，就会触发该事件
  + history提供了两个操作历史栈的API: history.pushState 和 history.replaceState
  + html5中新增了上面这两个方法，该两个方法也可以改变url，页面也不会重新刷新。
### 19. Vuex为什么是单向数据流 数据流关系
- 在双向数据流中，Model（可以理解为状态的集合） 中可以修改自己或其他Model的状态， 用户的操作（如在输入框中输入内容）也可以修改状态。这使改变一个状态有可能会触发一连串的状态的变化，最后很难预测最终的状态是什么样的。使得代码变得很难调试
- 在单向数据流中，当你需要修改状态，完全重新开始走一个修改的流程。这限制了状态修改的方式，让状态变得可预测，容易调试。
### 20. Mutation为什么不能放异步
- 每个mutation执行完成后都会对应到一个新的状态变更，这样devtools就可以打个快照存下来，然后就可以实现 time-travel 了。如果mutation支持异步操作，就没有办法知道状态是何时更新的，无法很好的进行状态的追踪，给调试带来困难。
###







