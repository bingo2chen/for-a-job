
### 1. Object.defineProperty 和 Proxy 区别
  + proxy
    + Proxy 可以直接监听对象而非属性
    + Proxy 可以直接监听数组变化
    + Proxy 拦截多达13种，不限于apply、 ownKeys、 deleteProperty、 has等等，Object.defineProperty不具备
    + Proxy 直接返回一个新对象，可以直接操作新对象，Object.defineProperty 只能遍历对象属性直接修改
  + Object.defineProperty
    + 兼容性好,⽀持IE9


  + 原理
  ```js
    Object.keys(data).forEach(function (key) {
      Object.defineProperty(data, key, {
        configurable: true,
        enumerable: true,
        get() {
          console.log('get get get');
        },
        set(newVal) {
          this.val = newVal
          console.log(newVal)
          say(newVal)
        }
      })
    })
  ```

  + 测试代码
  ```js
    // 这是将要被劫持的对象
    // 测试代码
    const data = {
      name: '',
    };
    function say(name) {
      if (name === '古天乐') {
        console.log('给⼤家推荐⼀款超好玩的游戏');
      } else if (name === '渣渣辉') {
        console.log('戏我演过很多,可游戏我只玩贪玩懒⽉');
      } else {
        console.log('来做我的兄弟');
      }
    } 
    data.name = '渣渣辉'
    data.name
  ```


### 2. 如何理解响应式系统
- 每个Vue component 都有一个 watcher 实例与之对应
- Vue 上的data 都会被添加上getter和setter属性
- Vue component render 函数被执行后，data的getter属性会被触碰，此时Vue会记录此时Vue component所依赖的所有data（搜集依赖）
- data被改动是，setter会被调用，此时Vue会通知所有依赖此data的组件去调用他们的render函数进行更新


### 3. key的作用
- key是vnode标记的唯一id，通过key，diff操作更准确和快速
- 准确：不加key，vue会复用节点（vue就地更新策略），导致之前节点的状态会被保留下来，产生一些列bug
- 快速：key的唯一性可被Map数据结构充分利用，遍历查找的时间复杂度为O(1)


### 4. v-if 和 v-for 哪个优先级更高？如果同时出现，怎么优化性能？
- v-for 优先级高于 v-if
- 同时出现，每次渲染都会先执行循环再判断条件，这样很浪费性能
- todo：外层嵌套template，在这一层进行v-if判断；如果判断条件在循环内部，则可以用计算属性过滤掉不需要显示的项


### 5. 组件为什么必须是个函数，Vue根实例没有这个限制
- vue组件有很多实例，如果使用对象的形式定义data，则他们会公用一个data对象，那么状态变更会影响所有组件实例，不合理；
- 采用函数形式定义，在initData时会将其作为工厂函数返回全新data对象，可以有效规避多实例之间状态污染的问题；
- 在Vue根实例没有限制是因为根实例只能有一个


### 6. 怎么理解diff算法
- 通过新旧dom做对比，将变化的地方更新到真实dom上，也需要diff高效的执行对比过程，从而降低时间复杂度O(n)
- 2.x版本为了降低Watcher颗粒度，每一个组件只有一个Watcher与之对应，只有引入diff才能精准找到发生变化的地方
- diff执行的时刻是组件实例执行更新函数时，它会对比上一次渲染结果oldVnode和新的newVnode，这个过程称为patch
- diff过程遵循深度优先，同层比较的策略；两个节点之间会比较他们是否拥有相同的子节点或文本节点做不同操作，比较两组子节点是算法的重点，首先假设头尾节点可能相同，做4次对比尝试，如果没找到相同节点，再按通用方式遍历查找，查找结束再按情况处理剩下节点，借助key可以非常精准查找到相同节点，因此整个patch过程非常高效


### 7. 谈谈对vue组件化的理解
- 组件：独立、可复用，组件系统是Vue核心特性之一
- 组件化开发能大幅提高应用开发效率、测试性和复用性
- 按分类有：页面组件、业务组件、通用组件
- 组件是基于可配置的，平时编写的组件是组件配置而非组件，框架后续会生成其构造函数，基于VueComponent，扩展于Vue
- 常见组件化技术：属性prop，自定义事件，插槽等
- 合理划分组件，有助于提升应用性能
- 组件应该是高内聚低耦合的
- 遵循单向数据流原则


### 8. 谈谈vue设计原则的理解
- 易用性，灵活性，高效性
- 渐进式JavaScript框架


### 9. 谈谈对mvc、mvp、mvvm理解






