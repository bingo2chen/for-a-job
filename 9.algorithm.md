### 二分查找

```js
function binarySearch(array, target) {
  let max = array.length - 1;
  let min = 0;
  while (min <= max) {
    let mid = Math.floor((max + min) / 2);
    if (target < array[mid]) {
      max = mid - 1;
    } else if (target > array[mid]) {
      min = mid + 1;
    } else {
      return mid;
    }
  }
  return -1;
}
```

### 线性查找
```js
const linearSearch = (array, target) => {
  for (let i = 0; i < array.length - 1; i++) {
    if (array[i] === target) {
      return i
    }
  }
  return -1
}
```


### 归并排序

```js
const mergeSort = (array) => {
  const len = array.length;
  if (len < 2) {
    return array;
  }
  const mid = Math.floor(len / 2);
  const left = array.slice(0, mid);
  const right = array.slice(mid);
  return merge(mergeSort(left), mergeSort(right));
  function merge(left, right) {
    const result = [];
    while (left.length && right.length) {
      if (left[0] <= right[0]) {
        result.push(left.shift());
      } else {
        result.push(right.shift());
      }
    }
    while (left.length) {
      result.push(left.shift());
    }
    while (right.length) {
      result.push(right.shift());
    }
    return result;
  }
};
```

### 冒泡排序

```js
// 传统冒泡
const bubbleSort1 = (array) => {
  let temp;
  for (let i = 0; i < array.length; i++) {
    for (let j = 0; j < array - i - 1; j++) {
      if (array[j] > array[j + 1]) {
        temp = array[j];
        array[j] = array[j + 1];
        array[j + 1] = temp;
      }
    }
  }
  return array;
};

// 改进版 - 1
// 设置⼀标志性变量pos,⽤于记录每趟排序中最后⼀次进⾏交换的位置。 由于pos位置之后的记录均已交换到位,故在进⾏下⼀趟排序时只要扫描到pos位置即可
const bubbleSort2 = (array) => {
  let i = array.length - 1;
  console.time("1---改进后冒泡排序耗时");
  while (i > 0) {
    let position = 0; // 标志位
    for (let j = 0; j < i; j++) {
      if (array[j] > array[j + 1]) {
        position = j;
        let temp = array[j];
        array[j] = array[j + 1];
        array[j + 1] = temp;
      }
    }
    i = position;
  }
  console.timeEnd("1---改进后冒泡排序耗时");
  return array;
};

// 改进版 - 2
// 传统冒泡排序中每⼀趟排序操作只能找到⼀个最⼤值或最⼩值,我们考虑利⽤在每趟排序中进⾏正向和反向两遍冒泡的⽅法⼀次可以得到两个最终值(最⼤者和最⼩者) , 从⽽使排序趟数⼏乎减少了⼀半
const bubbleSort3 = (array) => {
  let low = 0;
  let high = array.length - 1;
  let temp, j;
  console.time("2---改进后冒泡排序耗时");
  while (low < high) {
    for (j = low; j < high; j++) {
      if (array[j] > array[j + 1]) {
        temp = array[j];
        array[j] = array[j + 1];
        array[j + 1] = temp;
      }
    }
    high--;
    for (j = high; j > low; j--) {
      if (array[j] < array[j - 1]) {
        temp = array[j];
        array[j] = array[j - 1];
        array[j - 1] = temp;
      }
    }
    low++;
  }
  console.timeEnd("2---改进后冒泡排序耗时");
  return array;
};

```

### 判断一个ip地址是否合法 

### // 输入: nums = [1, 1, 1, 2, 2, 3, 9], k = 2  输出: [1, 2] 输出出现次数大于k的值
```js
function myPromiseAll(nums, k) {
  const temp = {}
  const ret = []
  for (let i = 0; i < nums.length; i++) {
    if (Object.keys(temp).indexOf(nums[i].toString()) === -1) {
      temp[nums[i]] = 1
    } else {
      temp[nums[i]] += 1
    }
  }
  console.log(temp);
  
  for (const key in temp) {
    if (temp[key] >= k) {
      ret.push(Number(key))
    }
  }
  return ret
}
myPromiseAll([1, 1, 1, 2, 2, 3, 9])
```
